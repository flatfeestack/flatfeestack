<!DOCTYPE html>
<html lang="en">
<head>
    <style>
        body {
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: #1a1a1a;
        }

        .container {
            width: 800px;
            height: 600px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        svg {
            width: 100%;
            height: 100%;
        }
    </style>
    <title>Test</title>
</head>
<body>
<div class="container">
    <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="-100 -50 800 900"
         id="floor">

        <g id="roll2-part2" transform="translate(425,-39)">
            <!-- Top press, lower part -->
            <path d="M55.086 67.746c-4.089.086-8.675 1.458-13.518 4.254-17.218 9.941-31.175 34.118-31.175 54 0 9.942 3.49 16.929 9.132 20.186L268.068 289.64l44.96-75.827L64.68 70.494c-2.69-1.875-5.944-2.824-9.594-2.748"
                  style="fill:#939393"/>
            <path d="M290.985 288c-17.219 9.941-31.177 1.882-31.177-18s13.958-44.059 31.177-54c17.218-9.941 31.176-1.882 31.176 18s-13.958 44.059-31.176 54"
                  style="fill:#b9b9b9"/>
        </g>

        <!-- Background group for scrolling floor -->
        <g id="scrollingFloor"></g>

        <g transform="translate(425,-39)">
            <!-- Top press, upper part 1 -->
            <path d="M20.785 108V36L0 24v72z" style="fill:#a3a3a3"/>
            <path d="M62.354 84V12l-41.57 24v72z" style="fill:#e1e1e1"/>
        </g>

        <g id="dots"></g>

        <g id="press1" transform="translate(-40,230)">
            <!-- Bottom press, lower part -->
            <path d="M55.086 67.746c-4.089.086-8.675 1.458-13.518 4.254-17.218 9.941-31.175 34.118-31.175 54 0 9.942 3.49 16.929 9.132 20.186L268.068 289.64l44.96-75.827L64.68 70.494c-2.69-1.875-5.944-2.824-9.594-2.748"
                  style="fill:#939393"/>
            <path d="M290.985 288c-17.219 9.941-31.177 1.882-31.177-18s13.958-44.059 31.177-54c17.218-9.941 31.176-1.882 31.176 18s-13.958 44.059-31.176 54"
                  style="fill:#b9b9b9"/>
            <!-- Bottom press, upper part -->
            <path d="M20.785 108V36L0 24v72z" style="fill:#a3a3a3"/>
            <path d="M62.354 84V12l-41.57 24v72z" style="fill:#e1e1e1"/>
            <path d="m20.785 36 41.569-24 249.415 144v24l-41.57 24v-24z" style="fill:#939393"/>
            <path d="m20.785 60 311.769 180v-24L20.784 36Z" style="fill:#606060"/>
            <path d="m290.985 192 41.569-24-20.785-12-41.57 24z" style="fill:#bebebe"/>
            <path d="M290.985 264v-72L270.2 180v72z" style="fill:#a3a3a3"/>
            <path d="m332.555 168-41.57 24v72l15.587-9v24l10.393-6v-24l15.59-9z" style="fill:#e1e1e1"/>
            <path d="m20.785 36 41.569-24L41.569 0 0 24Z" style="fill:#bebebe"/>
            <path d="m306.573 279-20.785-12v-6l5.197 3 15.588-9z" style="fill:#a3a3a3"/>
        </g>

        <g transform="translate(425,-39)">
            <!-- Top press, upper part 2-->
            <path d="m20.785 36 41.569-24 249.415 144v24l-41.57 24v-24z" style="fill:#939393"/>
            <path d="m20.785 60 311.769 180v-24L20.784 36Z" style="fill:#606060"/>
            <path d="m290.985 192 41.569-24-20.785-12-41.57 24z" style="fill:#bebebe"/>
            <path d="M290.985 264v-72L270.2 180v72z" style="fill:#a3a3a3"/>
            <path d="m332.555 168-41.57 24v72l15.587-9v24l10.393-6v-24l15.59-9z" style="fill:#e1e1e1"/>
            <path d="m20.785 36 41.569-24L41.569 0 0 24Z" style="fill:#bebebe"/>
            <path d="m306.573 279-20.785-12v-6l5.197 3 15.588-9z" style="fill:#a3a3a3"/>
        </g>
    </svg>
</div>

<script>
    let viewY = 0;
    let viewOffsetX = 468;  // Base X position
    let viewOffsetY = 55; // Base Y position

    const COLORS = {
        YELLOW: {
            light: "#ffd54f",
            dark: "#ffb300"
        },
        RED: {
            light: "#e63835",
            dark: "#ca1c19"
        },
        GREEN: {
            light: "#bbda9b",
            dark: "#7cb342"
        },
        BLUE: {
            light: "#4a90e2",
            dark: "#2171d0"
        },
        PURPLE: {
            light: "#9575cd",
            dark: "#5e35b1"
        },
        ORANGE: {
            light: "#ff9800",
            dark: "#f57c00"
        },
        PINK: {
            light: "#ec407a",
            dark: "#d81b60"
        },
        TEAL: {
            light: "#26a69a",
            dark: "#00897b"
        },
        CYAN: {
            light: "#4dd0e1",
            dark: "#00acc1"
        },
        BROWN: {
            light: "#a1887f",
            dark: "#795548"
        }
    };

    // Create a dot element (the double circle)
    function createDot(id, position, colors) {
        const {x, y} = position;
        const {light, dark} = colors;
        const group = document.createElementNS("http://www.w3.org/2000/svg", "g");
        group.setAttribute("id", `dot-${id}`);

        // Front circle
        const path1 = document.createElementNS("http://www.w3.org/2000/svg", "path");
        path1.setAttribute("d", "M31.99 225.998c-5.718 3.301-5.67 8.681.106 12.016 5.777 3.336 15.096 3.364 20.815.063 5.718-3.302 5.67-8.682-.108-12.018-5.777-3.335-15.096-3.363-20.814-.061m5.26 3.037c2.842-1.64 7.474-1.627 10.346.03 2.873 1.658 2.896 4.333.054 5.974s-7.475 1.627-10.347-.03c-2.87-1.659-2.895-4.333-.053-5.974");
        path1.setAttribute("style", `fill:${light};`);
        path1.setAttribute("transform", `translate(${x - 0.988},${y - 196.054})`);

        // Back circle
        const path2 = document.createElementNS("http://www.w3.org/2000/svg", "path");
        path2.setAttribute("d", "M32.203 222.032c-5.717 3.301-5.67 8.681.108 12.017 5.777 3.335 15.096 3.363 20.814.062s5.67-8.682-.107-12.018c-5.778-3.335-15.097-3.363-20.815-.061m5.261 3.037c2.843-1.64 7.475-1.627 10.347.03 2.872 1.659 2.896 4.333.053 5.974s-7.475 1.627-10.346-.03c-2.872-1.659-2.895-4.333-.054-5.974");
        path2.setAttribute("style", `fill:${dark};`);
        path2.setAttribute("transform", `translate(${x - 0.988},${y - 196.054})`);

        // Additional details
        const path3 = document.createElementNS("http://www.w3.org/2000/svg", "path");
        path3.setAttribute("d", "M28.58 230.453a5.8 5.8 0 0 1-.625-2.507h-.036l-.177 3.579zM57.353 227.998c.007.828-.167 1.771-.573 2.563l.384 1.778z");
        path3.setAttribute("style", `fill:${light};`);
        path3.setAttribute("transform", `translate(${x - 0.988},${y - 196.054})`);

        group.appendChild(path1);
        group.appendChild(path2);
        group.appendChild(path3);

        return group;
    }

    function createLeftMerge(id, position, colors) {
        const {x, y} = position;
        const {light, dark} = colors;

        const group = document.createElementNS("http://www.w3.org/2000/svg", "g");
        group.setAttribute("id", `arrow-${id}`);

        // First light part of the arrow
        const lightPath1 = document.createElementNS("http://www.w3.org/2000/svg", "path");
        lightPath1.setAttribute("d", "m44.436 222.845-3.3 1.905-2.062-1.19-.824.476v.952l.824-.476 2.062 1.19 3.3-1.904z");
        lightPath1.setAttribute("style", `fill:${light}`);
        lightPath1.setAttribute("transform", `matrix(4.2 0 0 4.2 ${x - 131.204} ${y - 907.95})`);

        // Second light part of the arrow
        const lightPath2 = document.createElementNS("http://www.w3.org/2000/svg", "path");
        lightPath2.setAttribute("d", "m41.549 222.131-.825.476v.953l.825-.477z");
        lightPath2.setAttribute("style", `fill:${light}`);
        lightPath2.setAttribute("transform", `matrix(4.2 0 0 4.2 ${x - 131.204} ${y - 907.95})`);

        // Dark part of the arrow
        const darkPath = document.createElementNS("http://www.w3.org/2000/svg", "path");
        darkPath.setAttribute("d", "m38.25 224.036.824-.476 2.062 1.19 3.3-1.905-1.65-.952-1.65.952-.412-.238.825-.476-2.887.238z");
        darkPath.setAttribute("style", `fill:${dark}`);
        darkPath.setAttribute("transform", `matrix(4.2 0 0 4.2 ${x - 131.204} ${y - 907.95})`);

        group.appendChild(lightPath1);
        group.appendChild(lightPath2);
        group.appendChild(darkPath);

        return group;
    }

    function createRightMerge(id, position, colors) {
        const {x, y} = position;
        const {light, dark} = colors;

        const group = document.createElementNS("http://www.w3.org/2000/svg", "g");
        group.setAttribute("id", `arrow-${id}`);

        // First light part of the arrow
        const lightPath1 = document.createElementNS("http://www.w3.org/2000/svg", "path");
        lightPath1.setAttribute("d", "m43.33 230.967 1.675-.967v-.967L43.33 230z");
        lightPath1.setAttribute("style", `fill:${light}`);
        lightPath1.setAttribute("transform", `matrix(4.13596 0 0 4.13596 ${x - 130.713} ${y - 919.273})`);

        // Dark part of the arrow
        const darkPath = document.createElementNS("http://www.w3.org/2000/svg", "path");
        darkPath.setAttribute("d", "m41.236 231.693.837-.484L39.98 230l3.35-1.934 1.675.967-1.675.967.419.242.851-.492-.433 1.701z");
        darkPath.setAttribute("style", `fill:${dark}`);
        darkPath.setAttribute("transform", `matrix(4.13596 0 0 4.13596 ${x - 130.713} ${y - 919.273})`);

        // Second light part of the arrow
        const lightPath2 = document.createElementNS("http://www.w3.org/2000/svg", "path");
        lightPath2.setAttribute("d", "M39.98 230.967V230l2.093 1.21-.837.483z");
        lightPath2.setAttribute("style", `fill:${light}`);
        lightPath2.setAttribute("transform", `matrix(4.13596 0 0 4.13596 ${x - 130.713} ${y - 919.273})`);

        // Third light part of the arrow
        const lightPath3 = document.createElementNS("http://www.w3.org/2000/svg", "path");
        lightPath3.setAttribute("d", "m44.6 229.75-.433 1.701-2.93.242v.967l2.93-.242.42-1.692z");
        lightPath3.setAttribute("style", `fill:${light}`);
        lightPath3.setAttribute("transform", `matrix(4.13596 0 0 4.13596 ${x - 130.713} ${y - 919.273})`);

        group.appendChild(lightPath1);
        group.appendChild(darkPath);
        group.appendChild(lightPath2);
        group.appendChild(lightPath3);

        return group;
    }

    function createUpDown(id, position, colors) {
        const {x, y} = position;
        const {light, dark} = colors;

        const group = document.createElementNS("http://www.w3.org/2000/svg", "g");
        group.setAttribute("id", `arrow-${id}`);

        // Light part of the arrow
        const lightPath = document.createElementNS("http://www.w3.org/2000/svg", "path");
        lightPath.setAttribute("d", "M55.898 222.727 50.229 226l-1.89-1.09V226l1.89 1.091 5.669-3.273z");
        lightPath.setAttribute("style", `fill:${light}`);
        lightPath.setAttribute("transform", `matrix(3.66673 0 0 3.66673 ${x - 149.536} ${y - 788.68})`);

        // Dark part of the arrow
        const darkPath = document.createElementNS("http://www.w3.org/2000/svg", "path");
        darkPath.setAttribute("d", "m54.008 221.637-5.668 3.272L50.23 226l5.668-3.273z");
        darkPath.setAttribute("style", `fill:${dark}`);
        darkPath.setAttribute("transform", `matrix(3.66673 0 0 3.66673 ${x - 149.536} ${y - 788.68})`);

        group.appendChild(lightPath);
        group.appendChild(darkPath);

        return group;
    }

    function createLeftRight(id, position, colors) {
        const {x, y} = position;
        const {light, dark} = colors;

        const group = document.createElementNS("http://www.w3.org/2000/svg", "g");
        group.setAttribute("id", `arrow-${id}`);

        // Light part of the arrow
        const lightPath = document.createElementNS("http://www.w3.org/2000/svg", "path");
        lightPath.setAttribute("d", "M43.458 220.091v.97l5.04 2.909 1.679-.97v-.97l-1.68.97z");
        lightPath.setAttribute("style", `fill:${light}`);
        lightPath.setAttribute("transform", `matrix(4.12488 0 0 4.12488 ${x - 151.548} ${y - 879.85})`);

        // Dark part of the arrow
        const darkPath = document.createElementNS("http://www.w3.org/2000/svg", "path");
        darkPath.setAttribute("d", "m45.138 219.121-1.68.97 5.04 2.91 1.679-.97z");
        darkPath.setAttribute("style", `fill:${dark}`);
        darkPath.setAttribute("transform", `matrix(4.12488 0 0 4.12488 ${x - 151.548} ${y - 879.85})`);

        group.appendChild(lightPath);
        group.appendChild(darkPath);

        return group;
    }

    function createCrossing(id, position, colors1, colors2) {
        const {x, y} = position;
        const {light: light1, dark: dark1} = colors1;
        const {light: light2, dark: dark2} = colors2;

        const group = document.createElementNS("http://www.w3.org/2000/svg", "g");
        group.setAttribute("id", `crossing-${id}`);

        // Upper line light part (top-most)
        const lightPath1 = document.createElementNS("http://www.w3.org/2000/svg", "path");
        lightPath1.setAttribute("d", "M55.426 28 34.64 40l-6.928-4v4l6.928 4 20.785-12Z");
        lightPath1.setAttribute("style", `fill:${light1}`);
        lightPath1.setAttribute("transform", `translate(${x}, ${y})`);

        // Upper line dark part
        const darkPath1 = document.createElementNS("http://www.w3.org/2000/svg", "path");
        darkPath1.setAttribute("d", "M48.497 24 27.713 36l6.928 4 20.785-12Z");
        darkPath1.setAttribute("style", `fill:${dark1}`);
        darkPath1.setAttribute("transform", `translate(${x}, ${y})`);

        // Lower crossing line dark part
        const darkPath2 = document.createElementNS("http://www.w3.org/2000/svg", "path");
        darkPath2.setAttribute("d", "m34.641 24-6.928 4 5.196 3v-4l10.392 6v4l5.196 3 6.929-4-5.197-3v-4l-10.392-6-3.464 2z");
        darkPath2.setAttribute("style", `fill:${dark2}`);
        darkPath2.setAttribute("transform", `translate(${x}, ${y})`);

        // Lower crossing line light part (bottom)
        const lightPath2 = document.createElementNS("http://www.w3.org/2000/svg", "path");
        lightPath2.setAttribute("d", "M27.713 28v4l3.464 2 3.464-2 6.928 4v4l6.928 4 6.929-4v-4l-6.929 4-5.196-3v-4L32.91 27v4z");
        lightPath2.setAttribute("style", `fill:${light2}`);
        lightPath2.setAttribute("transform", `translate(${x}, ${y})`);

        // Add paths in correct order for proper layering
        group.appendChild(darkPath1);   // Top dark line
        group.appendChild(lightPath1);  // Top light line
        group.appendChild(darkPath2);   // Bottom dark line
        group.appendChild(lightPath2);  // Bottom light line

        return group;
    }

    function createLeftBranch(id, position, colors) {
        const {x, y} = position;
        const {light, dark} = colors;

        const group = document.createElementNS("http://www.w3.org/2000/svg", "g");
        group.setAttribute("id", `arrow-${id}`);

        // First light part of the arrow
        const lightPath1 = document.createElementNS("http://www.w3.org/2000/svg", "path");
        lightPath1.setAttribute("d", "m48.497 40-6.928-4-1.732 1v4l1.732-1 6.928 4z");
        lightPath1.setAttribute("style", `fill:${light}`);
        lightPath1.setAttribute("transform", `translate(${x}, ${y})`);

        // Second light part of the arrow (combining both paths)
        const lightPath2 = document.createElementNS("http://www.w3.org/2000/svg", "path");
        lightPath2.setAttribute("d", "m43.301 39-12.124-1-1.732-7v4l1.732 7L43.3 43zM55.426 36l-6.929 4v4l6.929-4Z");
        lightPath2.setAttribute("style", `fill:${light}`);
        lightPath2.setAttribute("transform", `translate(${x}, ${y})`);

        // Dark part of the arrow
        const darkPath = document.createElementNS("http://www.w3.org/2000/svg", "path");
        darkPath.setAttribute("d", "m29.445 31 3.464 2 8.66-5 13.857 8-6.929 4-6.928-4-1.732 1 3.464 2-12.124-1z");
        darkPath.setAttribute("style", `fill:${dark}`);
        darkPath.setAttribute("transform", `translate(${x}, ${y})`);

        group.appendChild(lightPath1);
        group.appendChild(lightPath2);
        group.appendChild(darkPath);

        return group;
    }

    function createRightBranch(id, position, colors) {
        const {x, y} = position;
        const {light, dark} = colors;

        const group = document.createElementNS("http://www.w3.org/2000/svg", "g");
        group.setAttribute("id", `arrow-${id}`);

        // First light part
        const lightPath1 = document.createElementNS("http://www.w3.org/2000/svg", "path");
        lightPath1.setAttribute("d", "m48.497 32-6.928 4-1.732 1v4l1.732-1 6.928-4z");
        lightPath1.setAttribute("style", `fill:${light};fill-opacity:1`);
        lightPath1.setAttribute("transform", `translate(${x}, ${y})`);

        // Second light part
        const lightPath2 = document.createElementNS("http://www.w3.org/2000/svg", "path");
        lightPath2.setAttribute("d", "m43.301 39-12.124-1-1.732-7v4l1.732 7L43.3 43z");
        lightPath2.setAttribute("style", `fill:${light};fill-opacity:1`);
        lightPath2.setAttribute("transform", `translate(${x}, ${y})`);

        // Third light part
        const lightPath3 = document.createElementNS("http://www.w3.org/2000/svg", "path");
        lightPath3.setAttribute("d", "m34.641 32-6.928-4v4l6.928 4z");
        lightPath3.setAttribute("style", `fill:${light};fill-opacity:1`);
        lightPath3.setAttribute("transform", `translate(${x}, ${y})`);

        // Dark part
        const darkPath = document.createElementNS("http://www.w3.org/2000/svg", "path");
        darkPath.setAttribute("d", "m29.445 31 3.464 2 1.732-1-6.928-4 6.928-4 13.856 8-8.66 5 3.464 2-12.124-1z");
        darkPath.setAttribute("style", `fill:${dark};fill-opacity:1`);
        darkPath.setAttribute("transform", `translate(${x}, ${y})`);

        // Add paths in correct order for proper layering

        group.appendChild(lightPath1);
        group.appendChild(lightPath2);
        group.appendChild(lightPath3);
        group.appendChild(darkPath);

        return group;
    }

    function createTile(x, y, isEven1, isEven2) {
        const tileWidth = 24;
        const tileHeight = 12;
        const isoXOffset = (tileWidth * 0.866025404);  // cos(30°) ≈ 0.866
        const depth = 3;

        let baseX = (x - y) * isoXOffset;
        let baseY = (x + y) * tileHeight;
        const group = document.createElementNS("http://www.w3.org/2000/svg", "g");

        const colors = isEven1 ^ isEven2 ? {
            top: "#ddd0c8",
            front: "#eaebdb",
            right: "#9f958b"
        } : {
            top: "#ece5df",
            front: "#eaebdb",
            right: "#9f958b"
        };

        // Top face
        const topFace = document.createElementNS("http://www.w3.org/2000/svg", "path");
        topFace.setAttribute("d", `m ${baseX},${baseY} l ${isoXOffset},${tileHeight} ${isoXOffset},-${tileHeight} -${isoXOffset},-${tileHeight} z`);
        topFace.setAttribute("fill", colors.top);
        group.appendChild(topFace);

        // Front face
        const frontFace = document.createElementNS("http://www.w3.org/2000/svg", "path");
        frontFace.setAttribute("d", `m ${baseX},${baseY} l ${isoXOffset},${tileHeight} 0,${depth} -${isoXOffset},-${tileHeight} z`);
        frontFace.setAttribute("fill", colors.front);
        group.appendChild(frontFace);

        // Right face
        const rightFace = document.createElementNS("http://www.w3.org/2000/svg", "path");
        rightFace.setAttribute("d", `m ${baseX + isoXOffset},${baseY + tileHeight} l ${isoXOffset},-${tileHeight} 0,${depth} -${isoXOffset},${tileHeight} z`);
        rightFace.setAttribute("fill", colors.right);
        group.appendChild(rightFace);

        return group;
    }

    function createRow(y, width) {
        const row = document.createElementNS("http://www.w3.org/2000/svg", "g");
        row.setAttribute("data-row", y);
        for (let x = 0; x < width; x++) {
            const isEven = (x + y) % 2 === 0;
            const tile = createTile(x, y, isEven);
            row.appendChild(tile);
        }
        return row;
    }

    function buildFloor(width, height) {
        const svg = document.getElementById('scrollingFloor');
        const group = document.createElementNS("http://www.w3.org/2000/svg", "g");
        group.setAttribute("id", "floorGroup");
        group.setAttribute("transform", `translate(${viewOffsetX},${viewOffsetY})`);

        for (let y = 0; y < height; y++) {
            const row1 = createRow(y, width);
            group.appendChild(row1);
        }

        svg.appendChild(group);
    }

    function createHorizontalLines(nextRowState, start, end, color) {
        const step = start < end ? 1 : -1;
        const distance = Math.abs(end - start);

        for (let j = 1; j < distance; j++) {
            const pos = start + (j * step);
            const position = calculatePosition(pos, nr);
            if (nextRowState[pos] && nextRowState[pos].type === 'line') {
                const cross = createCrossing(Date.now(), position, nextRowState[pos].color, color);
                nextRowState[pos] = {
                    type: 'cross',
                    color: nextRowState[pos].color,
                    branch: currentRowState[start].branch,
                    element: cross,
                    index: pos,
                    nr: nr
                };
            } else {
                const hline = createLeftRight(Date.now(), position, color);
                nextRowState[pos] = {
                    type: 'hline',
                    color: color,
                    branch: currentRowState[start].branch,
                    element: hline,
                    index: pos,
                    nr: nr
                };
            }
        }
    }

    let frameCount = 0;
    let lastFpsUpdate = 0;
    const MOVEMENT_SPEED = 3; // Adjust this value to control speed
    let  dots = [];
    let currentRowState = Array(12).fill(null);
    let nr = 1;

    function getRandomColorPair(rowState) {
        // Get all used colors from rowState
        const usedColors = rowState
            .filter(state => state !== null)
            .map(state => state.color);

        // Get all available colors that aren't used in the current row
        const availableColors = Object.values(COLORS).filter(color =>
            !usedColors.some(usedColor =>
                usedColor.light === color.light && usedColor.dark === color.dark
            )
        );

        // If all colors are used, return a random color (fallback)
        if (availableColors.length === 0) {
            return Object.values(COLORS)[Math.floor(Math.random() * Object.values(COLORS).length)];
        }

        // Return a random color from available colors
        return availableColors[Math.floor(Math.random() * availableColors.length)];
    }

    function animate(timestamp) {

        const deltaTime = timestamp - lastFrameTime;

        // for some reason lastFrameTime is NaN at the beginning
        if (isNaN(deltaTime)) {
            requestAnimationFrame(animate);
            return;
        }


        const diff = MOVEMENT_SPEED * (deltaTime / 1000);
        viewY += diff

        const tileHeight = 12;

        // Check if we've scrolled one tile height using modulo
        if ((viewY % tileHeight) < diff) {
            removeTopRow(group);
            for (let i = 0; i < 12; i++) {
                if (currentRowState[i] && currentRowState[i].nr > 20) {
                    const dotsGroup = document.getElementById('dots');

                    if (dotsGroup.firstChild) {
                        dotsGroup.removeChild(dotsGroup.firstChild);
                    }
                    break;
                }

            }

            const newRow = addRowToBottom(group, 12);
            const nextRowState = Array(12).fill(null);

            //first row
            if (nr === 1) {
                for (let i = 0; i < 3; i++) {
                    // 50% chance to create a new dot
                    const randomColor = getRandomColorPair(nextRowState);
                    const position = calculatePosition(i * 4, nr); // 23 is the last row
                    const newDot = createDot(Date.now(), position, randomColor);
                    nextRowState[i * 4] = {
                        type: 'dot',
                        color: randomColor,
                        branch: i * 4,
                        element: newDot,
                        index: i * 4,
                        nr: nr
                    };
                }
                //branch
                for (let i = 0; i < 12; i++) {
                    if (nextRowState[i] && nextRowState[i].type === 'dot') {
                        if (Math.random() < 0.5) {
                            // Check both directions
                            // Check left direction - scan until we hit a dot or reach the end
                            let leftTargets = -1;
                            for (let left = i + 1; left < 12; left++) {
                                if (!nextRowState[left]) {
                                    leftTargets = left;
                                    break;
                                } else if (nextRowState[left]?.type === 'dot') {
                                    break
                                }
                            }


                            // Check right direction - scan until we hit a dot or reach the start
                            let rightTargets = -1;
                            for (let right = i - 1; right >= 0; right--) {
                                if (!nextRowState[right]) {
                                    rightTargets = right;
                                    break;
                                } else if (nextRowState[right]?.type === 'dot') {
                                    break;
                                }
                            }


                            // If we have possible directions, randomly choose one
                            if (leftTargets >= 0 && rightTargets >= 0) {
                                if (Math.random() < 0.5) {
                                    // Choose random left target
                                    const targetIndex = leftTargets;
                                    const position = calculatePosition(targetIndex, nr);
                                    const randomColor = getRandomColorPair(nextRowState);
                                    const leftArrow = createRightBranch(Date.now(), position, randomColor);
                                    nextRowState[targetIndex] = {
                                        type: 'branch-left',
                                        color: randomColor,
                                        branch: i,
                                        element: leftArrow,
                                        index: targetIndex,
                                        nr: nr
                                    };
                                } else {
                                    // Choose random right target
                                    const targetIndex = rightTargets;
                                    const position = calculatePosition(targetIndex, nr);
                                    const randomColor = getRandomColorPair(nextRowState);
                                    const rightArrow = createLeftBranch(Date.now(), position, randomColor);
                                    nextRowState[targetIndex] = {
                                        type: 'branch-right',
                                        color: randomColor,
                                        branch: i,
                                        element: rightArrow,
                                        index: targetIndex,
                                        nr: nr
                                    };
                                }
                            } else if (leftTargets >= 0) {
                                // Choose random left target
                                const targetIndex = leftTargets;
                                const position = calculatePosition(targetIndex, nr);
                                const randomColor = getRandomColorPair(nextRowState);
                                const leftArrow = createRightBranch(Date.now(), position, randomColor);
                                nextRowState[targetIndex] = {
                                    type: 'branch-left',
                                    color: randomColor,
                                    branch: i,
                                    element: leftArrow,
                                    index: targetIndex,
                                    nr: nr
                                };
                            } else if (rightTargets >= 0) {
                                // Choose random right target
                                const targetIndex = rightTargets;
                                const position = calculatePosition(targetIndex, nr);
                                const randomColor = getRandomColorPair(nextRowState);
                                const rightArrow = createLeftBranch(Date.now(), position, randomColor);
                                nextRowState[targetIndex] = {
                                    type: 'branch-right',
                                    color: randomColor,
                                    branch: i,
                                    element: rightArrow,
                                    index: targetIndex,
                                    nr: nr
                                };
                            }
                        }
                    }
                }
            } else { //all other rows
                for (let i = 0; i < 12; i++) {
                    if (currentRowState[i]) {
                        if (currentRowState[i].type === 'dot' ||
                            currentRowState[i].type === 'branch-right' ||
                            currentRowState[i].type === 'branch-left' ||
                            currentRowState[i].type === 'cross' ||
                            currentRowState[i].type === 'line') {
                            const r = Math.random();
                            if (r < 0.2 && currentRowState[i].type !== 'dot') {
                                //commit
                                const position = calculatePosition(i, nr);
                                const dot = createDot(Date.now(), position, currentRowState[i].color);
                                nextRowState[i] = {
                                    type: 'dot',
                                    color: currentRowState[i].color,
                                    branch: currentRowState[i].branch,
                                    element: dot,
                                    index: i,
                                    nr: nr
                                };
                            } else {
                                //continue
                                const position = calculatePosition(i, nr);
                                const line = createUpDown(Date.now(), position, currentRowState[i].color);
                                nextRowState[i] = {
                                    type: 'line',
                                    color: currentRowState[i].color,
                                    branch: currentRowState[i].branch,
                                    element: line,
                                    index: i,
                                    nr: nr
                                };
                            }
                        }

                    }
                }

                for (let i = 0; i < 12; i++) {
                    if (currentRowState[i] && nextRowState[i] && nextRowState[i].type === 'line') {
                        if (currentRowState[i].type === 'dot' ||
                            currentRowState[i].type === 'branch-right' ||
                            currentRowState[i].type === 'branch-left' ||
                            currentRowState[i].type === 'cross' ||
                            currentRowState[i].type === 'line') {

                            const r = Math.random();
                            if (r < 0.5 && currentRowState[i].branch !== i) {
                                //merge here
                                let origin = nextRowState[i].branch;
                                const isGoingLeft = origin < i;
                                const start = Math.min(i, origin);
                                const end = Math.max(i, origin);

                                let canReachOrigin = nextRowState[origin] && nextRowState[origin].type === 'dot';
                                for (let j = start + 1; j < end; j++) {
                                    if (nextRowState[j]?.type === 'dot' || nextRowState[j]?.type === 'cross' || nextRowState[j]?.type === 'merge-left' || nextRowState[j]?.type === 'merge-right') {
                                        canReachOrigin = false;
                                        break;
                                    }
                                }

                                if (canReachOrigin) {
                                    // Create merge arrow based on direction
                                    const position = calculatePosition(i, nr);
                                    if (isGoingLeft) {
                                        const leftArrow = createLeftMerge(Date.now(), position, currentRowState[i].color);
                                        //remove the previous
                                        nextRowState[i] = {
                                            type: 'merge-left',
                                            color: currentRowState[i].color,
                                            branch: origin,
                                            element: leftArrow,
                                            index: i,
                                            nr: nr
                                        };

                                    } else {
                                        const rightArrow = createRightMerge(Date.now(), position, currentRowState[i].color);
                                        //remove the previous
                                        nextRowState[i] = {
                                            type: 'merge-right',
                                            color: currentRowState[i].color,
                                            branch: origin,
                                            element: rightArrow,
                                            index: i,
                                            nr: nr
                                        };

                                    }

                                    // Create horizontal lines connecting to origin
                                    if (Math.abs(origin - i) > 1) {
                                        createHorizontalLines(nextRowState, i, origin, currentRowState[i].color);
                                    }
                                }
                            }
                        }
                    }
                }

                //branch
                for (let i = 0; i < 12; i++) {
                    if (nextRowState[i] && nextRowState[i].type === 'dot') {
                        if (Math.random() < 0.5) {
                            // Check both directions
                            // Check left direction - scan until we hit a dot or reach the end
                            let leftTargets = -1;
                            let c = 0;
                            for (let left = i + 1; left < 12; left++) {
                                c++
                                if (!nextRowState[left]) {
                                    leftTargets = left;
                                    break;
                                } else if (nextRowState[left]?.type === 'dot' || nextRowState[left]?.type === 'merge-left' || nextRowState[left]?.type === 'merge-right' || nextRowState[left]?.type === 'hline') {
                                    break
                                } else if (c > 1) {
                                    break
                                }
                            }

                            // Check right direction - scan until we hit a dot or reach the start
                            let rightTargets = -1;
                            c = 0;
                            for (let right = i - 1; right >= 0; right--) {
                                c++
                                if (!nextRowState[right]) {
                                    rightTargets = right;
                                    break;
                                } else if (nextRowState[right]?.type === 'dot' || nextRowState[right]?.type === 'merge-left' || nextRowState[right]?.type === 'merge-right' || nextRowState[right]?.type === 'hline') {
                                    break;
                                } else if (c > 1) {
                                    break
                                }
                            }

                            // If we have possible directions, randomly choose one
                            if (leftTargets >= 0 && rightTargets >= 0) {
                                if (Math.random() < 0.5) {
                                    // Choose random left target
                                    const targetIndex = leftTargets;
                                    const randomColor = getRandomColorPair(nextRowState);

                                    // Create horizontal lines for gap
                                    if (targetIndex - i !== 0) {
                                        createHorizontalLines(nextRowState, i, targetIndex, randomColor);
                                    }

                                    const position = calculatePosition(targetIndex, nr);
                                    const leftArrow = createRightBranch(Date.now(), position, randomColor);
                                    nextRowState[targetIndex] = {
                                        type: 'branch-left',
                                        color: randomColor,
                                        branch: currentRowState[i].branch,
                                        element: leftArrow,
                                        index: targetIndex,
                                        nr: nr
                                    };
                                } else {
                                    // Choose random right target
                                    const targetIndex = rightTargets;
                                    const position = calculatePosition(targetIndex, nr);
                                    const randomColor = getRandomColorPair(nextRowState);

                                    const rightArrow = createLeftBranch(Date.now(), position, randomColor);
                                    nextRowState[targetIndex] = {
                                        type: 'branch-right',
                                        color: randomColor,
                                        branch: currentRowState[i].branch,
                                        element: rightArrow,
                                        index: targetIndex,
                                        nr: nr
                                    };

                                    // Create horizontal lines for gap
                                    if (targetIndex - i !== 0) {
                                        createHorizontalLines(nextRowState, i, targetIndex, randomColor);
                                    }
                                }
                            } else if (leftTargets >= 0) {
                                // Choose random left target
                                const targetIndex = leftTargets;
                                const position = calculatePosition(targetIndex, nr);
                                const randomColor = getRandomColorPair(nextRowState);

                                // Create horizontal lines for gap
                                if (targetIndex - i !== 0) {
                                    createHorizontalLines(nextRowState, i, targetIndex, randomColor);
                                }

                                const leftArrow = createRightBranch(Date.now(), position, randomColor);
                                nextRowState[targetIndex] = {
                                    type: 'branch-left',
                                    color: randomColor,
                                    branch: currentRowState[i].branch,
                                    element: leftArrow,
                                    index: targetIndex,
                                    nr: nr
                                };
                            } else if (rightTargets >= 0) {
                                // Choose random right target
                                const targetIndex = rightTargets;
                                const position = calculatePosition(targetIndex, nr);
                                const randomColor = getRandomColorPair(nextRowState);

                                const rightArrow = createLeftBranch(Date.now(), position, randomColor);
                                nextRowState[targetIndex] = {
                                    type: 'branch-right',
                                    color: randomColor,
                                    branch: i,
                                    element: rightArrow,
                                    index: targetIndex,
                                    nr: nr
                                };

                                // Create horizontal lines for gap
                                if (targetIndex - i !== 0) {
                                    createHorizontalLines(nextRowState, i, targetIndex, randomColor);
                                }
                            }
                        }
                    }
                }
            }

            nextRowState.sort((a, b) => {
                // Find states containing these elements
                let stateA = Object.values(nextRowState).find(state => state?.element === a);
                let stateB = Object.values(nextRowState).find(state => state?.element === b);

                // If both states exist, compare their indexes
                if (stateA && stateB) {
                    return stateA.index - stateB.index;
                }

                // If only one state exists, put the one without state at the end
                if (stateA) return -1;
                if (stateB) return 1;

                // If neither has state, keep original order
                return 0;
            });

            const groupX = document.createElementNS("http://www.w3.org/2000/svg", "g");
            for (let i = 0; i < 12; i++) {
                if (nextRowState[i]) {
                    groupX.appendChild(nextRowState[i].element);
                    dots.push(nextRowState[i].element);
                }
            }
            const dotsGroup = document.getElementById('dots');
            dotsGroup.appendChild(groupX)

            currentRowState = nextRowState
            nr++;
        }

        const xOffset = viewY * Math.sqrt(3);
        const xt = viewOffsetX + xOffset;
        const yt = viewOffsetY - viewY;

        group.setAttribute("transform", `translate(${xt},${yt})`);

        dots = dots.filter(dot => {
            if (!dot.isConnected) {
                return false;
            }
            dot.setAttribute("transform", `translate(${xt},${yt})`);
            return true;
        });

        // FPS calculation
        frameCount++;
        if (timestamp - lastFpsUpdate >= 1000) {  // Update every second
            console.log(`FPS: ${frameCount} ${xt}/${yt}`);
            frameCount = 0;
            lastFpsUpdate = timestamp;
        }


        lastFrameTime = timestamp;
        requestAnimationFrame(animate);
    }

    function addRowToBottom(group, width) {
        const lastRow = group.lastChild;
        const lastRowIndex = parseInt(lastRow?.getAttribute("data-row") || "-1");
        const newRow = createRow(lastRowIndex + 1, width);
        group.appendChild(newRow);
        return newRow;
    }

    function removeTopRow(group) {
        if (group.firstChild) {
            group.removeChild(group.firstChild);
        }
    }

    function calculatePosition(xCoord, yCoord, tileOffset = {x: 3, y: -19}) {
        const tileWidth = 24;
        const tileHeight = 12;
        const isoXOffset = tileWidth * 0.866025404;  // ≈ 20.784

        // Adjust coordinates based on tile offset
        const offsetX = xCoord - tileOffset.x;
        const offsetY = yCoord - tileOffset.y;

        // Calculate base position for the first tile (0,0)
        const baseX = 0;
        const baseY = 0;

        // Convert grid coordinates to isometric position
        const isoX = (offsetX - offsetY) * isoXOffset;
        const isoY = (offsetX + offsetY) * tileHeight;

        // Calculate final position
        const x = baseX + isoX + isoXOffset;
        const y = baseY + isoY + tileHeight;

        return {x, y};
    }

    // Initial build
    buildFloor(12, 24);

    let lastFrameTime = 0;
    const group = document.getElementById('floorGroup');
    animate();
</script>
</body>
</html>